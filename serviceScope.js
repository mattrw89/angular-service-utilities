// Generated by CoffeeScript 1.3.3
(function() {
  var debounce, digestOnceOnNextTick, mergeObject,
    __slice = [].slice;

  debounce = function(fn) {
    var timeout;
    timeout = null;
    return function() {
      var args, context;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      context = this;
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        timeout = null;
        return fn.call.apply(fn, [context].concat(__slice.call(args)));
      }, 0);
      return null;
    };
  };

  mergeObject = function(src, dst) {
    if (src === dst) {
      return dst;
    }
    if (!angular.isArray(src) && !angular.isObject(src)) {
      return src;
    }
    if (angular.isUndefined(dst)) {
      return src;
    }
    angular.forEach(src, function(value, key) {
      if ((typeof key.charAt === "function" ? key.charAt(0) : void 0) === '$') {
        return;
      }
      if ((angular.isObject(value) && angular.isObject(dst[key])) || (angular.isArray(value) && angular.isArray(dst[key]))) {
        return mergeObject(value, dst[key]);
      } else if (dst[key] !== value) {
        return dst[key] = value;
      }
    });
    if (angular.isArray(dst) && angular.isArray(src)) {
      dst.length = src.length;
    } else {
      angular.forEach(dst, function(value, key) {
        if ((typeof key.charAt === "function" ? key.charAt(0) : void 0) === '$') {
          return;
        }
        if (angular.isUndefined(src[key])) {
          return delete dst[key];
        }
      });
    }
    return dst;
  };

  digestOnceOnNextTick = function($scope) {
    if (!($scope.$$digestOnceOnNextTick != null)) {
      $scope.$$digestOnceOnNextTick = debounce(function() {
        return $scope.$digest();
      });
    }
    return $scope.$$digestOnceOnNextTick();
  };

  angular.module('serviceScope').factory('$serviceScope', [
    '$rootScope', '$q', function($rootScope, $q) {
      return function() {
        var $serviceScope, promises, removeWatcherFunctions;
        $serviceScope = $rootScope.$new(true);
        promises = {};
        $serviceScope.$get = function(name) {
          return promises[name].then(function() {
            return $serviceScope[name];
          });
        };
        $serviceScope.$defer = function(name) {
          var deferred;
          deferred = $q.defer();
          promises[name] = deferred.promise.then(function(actualValue) {
            $serviceScope[name] = actualValue;
            return digestOnceOnNextTick($serviceScope);
          });
          return deferred;
        };
        $serviceScope.$update = function(name, value) {
          return $serviceScope[name] = mergeObject(value, $serviceScope[name]);
        };
        removeWatcherFunctions = [];
        $serviceScope.$attachProperty = function(property) {
          return {
            to: function($scope, name) {
              var removeOurWatcher, removeTheirWatcher, removeWatchers;
              removeTheirWatcher = $scope.$watch(name, function() {
                $serviceScope[property] = mergeObject($scope[name], $serviceScope[property]);
                return digestOnceOnNextTick($serviceScope);
              });
              removeOurWatcher = $serviceScope.$watch(property, function() {
                $scope[name] = mergeObject($serviceScope[property], $scope[name]);
                return digestOnceOnNextTick($scope);
              });
              removeWatchers = function() {
                removeTheirWatcher();
                removeOurWatcher();
                return removeWatcherFunctions.splice(removeWatcherFunctions.indexOf(removeWatchers, 1));
              };
              $scope.$on('$destroy', removeWatchers);
              removeWatcherFunctions.push(removeWatchers);
              $scope[name] = $serviceScope[property];
              return $scope[name];
            }
          };
        };
        $serviceScope.$attach = function($scope, name) {
          var removeOurWatcher, removeTheirWatcher, removeWatchers;
          removeTheirWatcher = $scope.$watch(name, function(newValue, oldValue) {
            if (newValue !== oldValue) {
              throw Error('$serviceScope was detached from scope');
              return removeWatchers();
            } else {
              return digestOnceOnNextTick($serviceScope);
            }
          });
          removeOurWatcher = $serviceScope.$watch(function() {
            return digestOnceOnNextTick($scope);
          });
          removeWatchers = function() {
            removeTheirWatcher();
            removeOurWatcher();
            return removeWatcherFunctions.splice(removeWatcherFunctions.indexOf(removeWatchers, 1));
          };
          $scope.$on('$destroy', removeWatchers);
          removeWatcherFunctions.push(removeWatchers);
          $scope[name] = $serviceScope;
          return $serviceScope;
        };
        $serviceScope.$on('$destroy', function() {
          return angular.forEach(removeWatcherFunctions, function(removeWatchers) {
            return removeWatchers();
          });
        });
        return $serviceScope;
      };
    }
  ]);

}).call(this);
